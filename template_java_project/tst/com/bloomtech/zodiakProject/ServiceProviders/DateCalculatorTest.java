package com.bloomtech.zodiakProject.ServiceProviders;

import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.testng.Assert;

import java.sql.Date;
import java.time.LocalDate;
import java.util.ArrayList;

import static com.bloomtech.zodiakProject.ServiceProviders.DateCalculator.earthSignsList;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;


// @SpringBootTest

// TODO: Tests done in DateCalc Test File! =)
public class DateCalculatorTest {


    @InjectMocks
    DateCalculator dateCalculator;

    @Mock
    UserGeneratorService userGeneratorService;


    @BeforeEach
    void setUp() {

        LocalDate validBirthDate = LocalDate.parse("12-23-1994");
        LocalDate misMatchBirthDate = LocalDate.parse("09-02-2001");
        LocalDate invalidBirthDate = LocalDate.parse("13/20/2023");

        initMocks(this);


        ArrayList<String> earthSignsList = new ArrayList<String>();
        earthSignsList.add("Capricorn");
        earthSignsList.add("Taurus");
        earthSignsList.add("Virgo");


    }


    /**
     * Happy case test for DateCalc Class, where a birthdate is provided, it is checked for validity, and then it is compared
     * @throws IllegalArgumentException - indicating an invalid formatted String will not be accepted.
     */
    @Test
    public void findUserZodiacAndElementalSign_UserProvidesValidBirthDate_correctZodiacAndElementalReturned() throws IllegalArgumentException {

        //Given - Check if user date is valid string

        String validBirthDate = "1995-11-09";

        when(UserGeneratorService.isValidString(validBirthDate)).thenReturn(true);


        //When : Evaluation is done between birthdate + Virgo seasonal date ranges.

        Assert.assertTrue(LocalDate.parse("2020-23-08").compareTo(LocalDate.parse(validBirthDate)) <= 1 && LocalDate.parse("2020-22-09").compareTo(LocalDate.parse(validBirthDate)) == -1);


        //THEN: Return Correct Answer

        String zodiacSign = earthSignsList.get(3);
        String elemental = "Earth";
        String zodiacElemental = zodiacSign + elemental;

        when(DateCalculator.findUserZodiacAndElementalSign(LocalDate.parse(validBirthDate))).thenReturn(zodiacElemental);



    }



    /**
     * EdgeCase 1 test for DateCalc Class, where an invalid birthdate is provided and exception is throwm
     * @throws IllegalArgumentException indicating the format provided by the user is invalid.
     */


    @Test
    public void findUserZodiacAndElementalSign_withInvalidBirthDate_ThrowsException() throws IllegalArgumentException {

        //Given - Evaluate validity of String Date
        String invalidBirthDate = "06/04/2002";

        when(UserGeneratorService.isValidString(invalidBirthDate)).thenReturn(false);

        //When = Comparison is done
        when(DateCalculator.findUserZodiacAndElementalSign(LocalDate.parse(invalidBirthDate))).thenThrow(IllegalArgumentException.class);

        //Then - Assert answer provided is FALSE

        String wrongZodiacElemental = "Capricorn, Earth";
        String correctZodiacElemental = "Gemini, Air";
        Assert.assertNotEquals(wrongZodiacElemental, correctZodiacElemental);
        assertThrows( IllegalArgumentException.class, ()-> {DateCalculator.findUserZodiacAndElementalSign(LocalDate.parse(invalidBirthDate));});



    }





    /**
     * EdgeCase 2 test for DateCalc Class, where a valid birthdate is provided
     * but the wrong zodiac and elemental is generated by method.
     * @param validBirthDate
     * @throws IllegalArgumentException
     */


    //TODO: FIX last line with assert statement

    @Test
    public void findUserZodiacAndElementalSign_ValidBirthDate_MisMatchZodiacElementalSign() throws IllegalArgumentException {

        //GIVEN: A user provided birthdate that is valid.

        String validBirthDate = "2002-04-06";
        String wrongZodiacElemental = "Capricorn, Earth";
        String correctZodiacElemental = "Gemini, Air";

        when(UserGeneratorService.isValidString(validBirthDate)).thenReturn(true);


        //When : Evaluation is done between birthdate + Virgo seasonal date ranges.

        when(DateCalculator.findUserZodiacAndElementalSign(LocalDate.parse(validBirthDate))).thenReturn(wrongZodiacElemental);

        //THEN: Return WRONG Answer for the user's birthdate!

        assertFalse(Boolean.parseBoolean(correctZodiacElemental = wrongZodiacElemental));


    }


}
