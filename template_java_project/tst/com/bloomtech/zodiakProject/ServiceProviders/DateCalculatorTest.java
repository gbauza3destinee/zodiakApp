package com.bloomtech.zodiakProject.ServiceProviders;

import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.testng.Assert;

import java.sql.Date;
import java.time.LocalDate;
import java.time.Month;
import java.time.MonthDay;
import java.util.ArrayList;

import static com.bloomtech.zodiakProject.ServiceProviders.DateCalculator.earthSignsList;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;



public class DateCalculatorTest {

    @InjectMocks
    DateCalculator dateCalculator;

    @Mock
    UserGeneratorService userGeneratorService;


    @BeforeEach
    void setUp() {
        dateCalculator = new DateCalculator();
        MonthDay validBirthDate = MonthDay.of(12,23);
        MonthDay misMatchBirthDate = MonthDay.of(9,02);
        MonthDay invalidBirthDate = MonthDay.of(02, 27);

        initMocks(this);


        ArrayList<String> earthSignsList = new ArrayList<String>();
        earthSignsList.add("Capricorn");
        earthSignsList.add("Pisces");
        earthSignsList.add("Virgo");


    }


    /**
     * Happy case test for DateCalc Class, where a birthdate is provided, it is checked for validity, and then it is compared
     * @throws IllegalArgumentException - indicating an invalid formatted String will not be accepted.
     */
    @Test
    public void findUserZodiac_UserProvidesValidBirthDate_correctZodiacReturned() throws IllegalArgumentException {

        //Given - Check if user date is valid string

        String validBirthDate = "1995-11-09";

        when(UserGeneratorService.isValidString(validBirthDate)).thenReturn(true);


        //When : Evaluation is done between birthdate + Virgo seasonal date ranges.

        Assert.assertTrue(LocalDate.parse("2020-23-08").compareTo(LocalDate.parse(validBirthDate)) <= 1 && LocalDate.parse("2020-22-09").compareTo(LocalDate.parse(validBirthDate)) == -1);


        //THEN: Return Correct Answer

        String zodiacSign = earthSignsList.get(3);
        String elemental = "Earth";
        String zodiacElemental = zodiacSign + elemental;

        when(dateCalculator.calculateZodiac(MonthDay.parse(validBirthDate))).thenReturn(zodiacElemental);



    }



    /**
     * EdgeCase 1 test for DateCalc Class, where an invalid birthdate is provided and exception is throwm
     * @throws IllegalArgumentException indicating the format provided by the user is invalid.
     */


    @Test
    public void findUserZodiac_withInvalidBirthDate_ThrowsException() throws IllegalArgumentException {

        //Given - Evaluate validity of String Date
        String invalidBirthDate = "06/04/2002";

        when(UserGeneratorService.isValidString(invalidBirthDate)).thenReturn(false);

        //When = Comparison is done
        when(dateCalculator.calculateZodiac(MonthDay.parse(invalidBirthDate))).thenThrow(IllegalArgumentException.class);

        //Then - Assert answer provided is FALSE

        String wrongZodiacElemental = "Capricorn, Earth";
        String correctZodiacElemental = "Gemini, Air";
        Assert.assertNotEquals(wrongZodiacElemental, correctZodiacElemental);
        assertThrows( IllegalArgumentException.class, ()-> {dateCalculator.calculateZodiac(MonthDay.parse(invalidBirthDate));});



    }





    /**
     * EdgeCase 2 test for DateCalc Class, where a valid birthdate is provided
     * but the wrong zodiac and elemental is generated by method.
     */



    @Test
    public void findZodiacElementalGroup_ValidBirthDate_correctElementalReturned() throws IllegalArgumentException {

        //GIVEN: A user provided birthdate that is valid.

        String validBirthDate = "2002-04-06";
        String wrongZodiacElemental = "Capricorn, Earth";
        String correctZodiacElemental = "Gemini, Air";

        when(UserGeneratorService.isValidString(validBirthDate)).thenReturn(true);


        //When : Evaluation is done between birthdate + Virgo seasonal date ranges.

        when(dateCalculator.calculateZodiac(MonthDay.parse(validBirthDate))).thenReturn(wrongZodiacElemental);


        //THEN: Return WRONG Answer for the user's birthdate!

        assertNotSame(correctZodiacElemental, wrongZodiacElemental);


    }


    @Test
    public void findZodiacElementalGroup_InvalidBirthDate_ExceptionThrown() throws IllegalArgumentException {

        //GIVEN: A user provided birthdate that is valid.

        String validBirthDate = "2002-04-06";
        String wrongZodiacElemental = "Earth";
        String correctZodiacElemental = "Air";

        when(UserGeneratorService.isValidString(validBirthDate)).thenReturn(true);


        //When : Evaluation is done between birthdate + Virgo seasonal date ranges.

        when(dateCalculator.calculateZodiac(MonthDay.parse(validBirthDate))).thenReturn(wrongZodiacElemental);


        //THEN: Return WRONG Answer for the user's birthdate!

        assertNotSame(correctZodiacElemental, wrongZodiacElemental);


    }


}
